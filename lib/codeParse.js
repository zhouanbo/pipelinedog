'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var fs = require('fs');
var path = require('path');
var _ = require('lodash');

var Util = require('./util');
var FileOperation = require('./fileOperation');
var Police = require('./police');

if (process.platform != 'win32') {
  var newline = "\n";
} else {
  var newline = "\r\n";
}

var CodeParse = {
  initCode: function initCode() {
    return '{\n  "name": "New Step",\n  "description": "A new step you just created",\n  "invoke": "",\n  "inputlists": [],\n  "options": [],\n  "input_expr": "",\n  "output_expr": "",\n  "output_files": []\n}';
  },

  syncEditorToState: function syncEditorToState(app) {
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    var codeobj = {};
    try {
      codeobj = JSON.parse(tool.code);
    } catch (e) {
      console.log('JSON not valid.');
      tool.valid = false;
      app.setState(app.state);
      return;
    }
    tool.valid = true;
    tool.codeobj = codeobj;
    tool.name = codeobj.name;
    tool.description = codeobj.description;
    app.setState(app.state);
  },

  syncStateToEditor: function syncStateToEditor(app) {
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    tool.code = JSON.stringify(tool.codeobj, null, "  ");
  },

  generateCommand: function generateCommand(app) {
    //combine each tool's command to generate a pipeline
    //parse every tool
    var originalTool = app.state.currentTool;
    for (var i = 0; i <= app.state.lastId; i++) {
      app.state.currentTool = i;
      if (!Police.checkToolDefinition(app)) {
        return false;
      }
      this.parseToolCommand(app);
      FileOperation.newParse(app);
    }
    app.state.currentTool = originalTool;

    if (process.platform != 'win32') {
      app.state.command = "#!/usr/bin/bash";
      app.state.command += newline + '#This code is generated by PipelineDog.' + newline;
      app.state.command += "cd " + app.state.workDir + newline;
      app.state.tools.map(function (level, i) {
        level.map(function (tool, i) {
          app.state.command += newline + tool.parsedCommand;
        }, this);
        app.state.command += newline + 'wait' + newline;
      });
    } else {
      app.state.command = 'REM This code is generated by PipelineDog.' + newline;
      app.state.command += "CD " + app.state.workDir + newline;
      app.state.tools.map(function (level, i) {
        level.map(function (tool, i) {
          app.state.command += newline + tool.parsedCommand;
        }, this);
      });
    }

    return true;
  },

  parseToolCommand: function parseToolCommand(app) {
    //replace placeholders and generate command for each tool

    //if these symbols are changed, the police class need to change accordingly.
    var scope = /[\{\}]/;
    var segment = '|';

    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);

    this.convertExpressions(app, scope, segment);

    if (!tool.looping) {
      //if the tool is not looping

      tool.parsedOptions = tool.codeobj.options.map(function (s, index) {
        //replace placeholders with the translated expressions
        var a = s.split(scope);
        for (var i = 1; i < a.length - 1; i += 2) {
          for (var j = 0; j < tool.options.length; j++) {
            if (a[i] == tool.options[j]) {
              a[i] = tool.expressions[j];
            }
          }
        }
        return a.join('');
      }, this);
      if (process.platform != 'win32') {
        tool.parsedCommand = tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&";
      } else {
        tool.parsedCommand = "START /wait " + tool.codeobj.invoke + " " + tool.parsedOptions.join(" ");
      }
    } else {
      //if the tool is looping

      tool.parsedCommand = "";

      var loopArray = [];
      for (var i = 0; i < tool.options.length; i++) {
        if (tool.expressions[i]) loopArray.push(tool.expressions[i].split('^LOOP^'));
      }

      loopArray[0].map(function (fn, index, array) {
        tool.parsedOptions = tool.codeobj.options.map(function (s, innerindex) {
          //replace placeholders with the translated expressions
          var a = s.split(scope);
          for (var i = 1; i < a.length - 1; i += 2) {
            for (var j = 0; j < tool.options.length; j++) {
              if (a[i] == tool.options[j]) {
                a[i] = loopArray[j][index];
              }
            }
          }
          return a.join('');
        }, this);

        if (index !== array.length - 1) {
          if (process.platform != 'win32') {
            tool.parsedCommand += tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&" + newline;
          } else {
            tool.parsedCommand += "START /wait " + tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + newline;
          }
        } else {
          if (process.platform != 'win32') {
            tool.parsedCommand += tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&";
          } else {
            tool.parsedCommand += "START /wait " + tool.codeobj.invoke + " " + tool.parsedOptions.join(" ");
          }
        }
      }, this);
    }

    //process looping for output files
    if (tool.expressions[tool.expressions.length - 1]) {
      tool.expressions[tool.expressions.length - 1] = tool.expressions[tool.expressions.length - 1].map(function (of, i) {
        if (of.indexOf('^LOOP^') == -1) {
          return of;
        } else {
          return of.split('^LOOP^');
        }
      }, this);
      tool.output_files = _.flattenDeep(tool.expressions[tool.expressions.length - 1]);
    }
  },

  convertExpressions: function convertExpressions(app, scope, segment) {
    //recognize LEASH expressions, also update output_files info
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    tool.expressions = [];
    tool.options = [];

    for (var key in tool.codeobj) {
      if (key.slice(-5) == '_expr') {
        tool.expressions.push(tool.codeobj[key]);
        tool.options.push(key.slice(0, -5).toUpperCase());
      }
    }
    tool.expressions.push(tool.codeobj.output_files);

    tool.expressions = tool.expressions.map(function (e, i, a) {
      //convert objects to standard LEASH
      if ((typeof e === 'undefined' ? 'undefined' : _typeof(e)) == "object" && !Array.isArray(e)) {
        //Long(object) format
        var pseudoString = "{";
        if (e.file) pseudoString += e.file + 'F|';
        if (e.line) pseudoString += e.line + 'L|';
        if (e.base) pseudoString += e.base + 'B|';
        if (e.extension) pseudoString += e.extension + 'E|';
        if (e.arrangement) pseudoString += e.arrangement + 'A|';
        if (pseudoString.slice(-1) == "|") pseudoString = pseudoString.slice(0, -1);
        pseudoString += "}";
        return i != a.length - 1 ? pseudoString : [pseudoString];
      } else {
        //Short(string or array) format
        return e;
      }
    }.bind(this));

    for (var j = 0; j < tool.expressions.length - 1; j++) {
      //translate each LEASH expressions
      if (tool.expressions[j] && _typeof(tool.expressions[j]) != "object") {
        var a = tool.expressions[j].split(scope);
        for (var i = 1; i < a.length - 1; i += 2) {
          a[i] = this.parseLEASH(a[i], tool, segment);
        }
        tool.expressions[j] = a.join("");
      }
    }

    var outfilesArray = []; //process output_files array
    tool.expressions[tool.expressions.length - 1].map(function (s) {
      var a = s.split(scope);
      if (a.length >= 3) {
        for (var i = 1; i < a.length - 1; i += 2) {
          outfilesArray.push(this.parseLEASH(a[i], tool, segment));
        }
      } else {
        outfilesArray.push(s);
      }
    }.bind(this));
    tool.expressions[tool.expressions.length - 1] = _.flattenDeep(outfilesArray);
  },

  parseLEASH: function parseLEASH(expression, tool, segment) {
    //parse LEASH expression and process inputlists
    var inputlists = tool.codeobj.inputlists;
    var segs = [];
    var f = [];
    var l = [];
    var b = [];
    var e = [];
    var a = "";

    expression.split(segment).map(function (s, i) {
      if (s.slice(-1) == 'F') {
        segs[0] = s;
      }
      if (s.slice(-1) == 'L') {
        segs[1] = s;
      }
      if (s.slice(-1) == 'B') {
        segs[2] = s;
      }
      if (s.slice(-1) == 'E') {
        segs[3] = s;
      }
      if (s.slice(-1) == 'A') {
        segs[4] = s;
      }
    });
    if (!segs[0]) {
      segs[0] = "-F";
    }
    if (!segs[1]) {
      segs[1] = "-L";
    }
    if (!segs[2]) {
      segs[2] = "P-B";
    }
    if (!segs[3]) {
      segs[3] = "''E";
    }
    if (!segs[4]) {
      segs[4] = "'n'A";
    }

    segs.map(function (s, i) {
      switch (s.slice(-1)) {

        case 'F':
          var inputlistArray = this.parseRange(s.slice(0, -1), inputlists.length, inputlists);
          inputlistArray.map(function (fl, i) {
            var readdata = fs.readFileSync(inputlists[fl - 1], 'utf8');
            if (readdata.slice(-1) == newline) {
              readdata = readdata.slice(0, -1);
            }
            readdata.split(newline).map(function (fline) {
              f.push(fline);
            }, this);
          }, this);
          break;

        case 'L':
          var lineArray = this.parseRange(s.slice(0, -1), f.length, f);
          lineArray.map(function (line, i) {
            l.push(f[line - 1]);
          }, this);
          break;

        case 'B':
          b = l.map(function (filename, i) {
            var name = [];
            var baseArray = [];
            var dirname = path.dirname(filename);
            var basename = path.basename(filename);
            var bases = basename.split('.');

            if (s.slice(0, 1) == 'P') {
              baseArray = this.parseRange(s.slice(1, -1), bases.length, bases);
            } else {
              baseArray = this.parseRange(s.slice(0, -1), bases.length, bases);
            }
            baseArray.map(function (base, i) {
              name.push(bases[base - 1]);
            }, this);
            return s.slice(0, 1) == 'P' ? path.join(dirname, name.join('.')) : name.join('.');
          }, this);
          break;

        case 'E':
          var r = '';
          e = b.map(function (filename, i) {
            var arr = s.slice(0, -1).split("'");
            for (var i = 0; i < arr.length - 1; i += 2) {
              var extensionString = arr[i + 1];
              if (arr[i] == 'PRE') {
                filename = extensionString + filename;
              } else {
                filename = filename + extensionString;
              }
            }

            return filename;
          });
          break;

        case 'A':
          var arrangeString = s.replace(/['"]+/g, '').slice(0, -1);
          if (arrangeString == 'c') {
            a = e.join(',');
          } else if (arrangeString == 's') {
            a = e.join(' ');
          } else if (arrangeString == 'a') {
            a = e;
          } else if (arrangeString == 'n') {
            a = e.join('');
          } else if (arrangeString == 'l') {
            tool.looping = true;
            a = e.join('^LOOP^');
          } else {
            a = e.map(function (filename, i) {
              return arrangeString + ' ' + filename;
            }).join(' ');
          }
          break;

      }
    }, this);
    return a;
  },

  parseRange: function parseRange(s, length, arr) {
    var r = [];
    if (s.indexOf('/') > -1) {
      //parse regex range
      var regex = new RegExp(s.slice(1, -1));
      arr.map(function (string, i) {
        if (string.search(regex) > -1) {
          r.push(i + 1);
        };
      }, this);
      return r;
    } else {
      //parse numeric range
      var a = s.split(',');
      a.map(function (ss, i) {
        if (ss.indexOf('-') > -1) {
          var b = ss.split('-');
          if (b[0] == "" && b[1] == "") {
            b[0] = 1;b[1] = length;
          } else if (b[1] == "") {
            b[1] = length;
          } else if (b[0] == "") {
            b[0] = 1;
          } else if (b.length > 2 || Number(b[0]) > Number(b[1])) {
            console.log("illegal range.");
            return;
          }
          for (var i = Number(b[0]); i <= Number(b[1]); i++) {
            r.push(i);
          }
        } else {
          r.push(Number(ss));
        }
      }, this);
      r.sort(function (x, y) {
        return x - y;
      });
      return _.uniq(r);
    }
  }

};

module.exports = CodeParse;